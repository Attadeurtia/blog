<!DOCTYPE html>
<html><head lang="en"><script src="/blog/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=blog/livereload" data-no-instant defer></script>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Design Patterns - Geoffrey</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="C’est quoi ?
Les patterns offrent des solutions à des problèmes récurrents rencontrés par les développeurs, Ils permettent de :

Limiter le couplage
Faciliter la maintenance
Être moins rigide face au changement

Ils sont indispensables à connaître pour le développeur :

Pour s’assurer d’une meilleure conception
Pour dialoguer avec les développeurs (à travers le “langage pattern”)
Pour comprendre les frameworks

Un livre écrit par le GoF (Gang of Four : Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides) décrit 23 Design Patterns appliqués à la conception orientée objet, classés en trois catégories :" />
	<meta property="og:image" content=""/>
	<meta property="og:url" content="http://localhost:1313/blog/posts/design_patterns/">
  <meta property="og:site_name" content="Geoffrey">
  <meta property="og:title" content="Design Patterns">
  <meta property="og:description" content="C’est quoi ? Les patterns offrent des solutions à des problèmes récurrents rencontrés par les développeurs, Ils permettent de :
Limiter le couplage Faciliter la maintenance Être moins rigide face au changement Ils sont indispensables à connaître pour le développeur :
Pour s’assurer d’une meilleure conception Pour dialoguer avec les développeurs (à travers le “langage pattern”) Pour comprendre les frameworks Un livre écrit par le GoF (Gang of Four : Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides) décrit 23 Design Patterns appliqués à la conception orientée objet, classés en trois catégories :">
  <meta property="og:locale" content="fr">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-04-24T17:49:47+02:00">
    <meta property="article:modified_time" content="2023-04-24T17:49:47+02:00">
    <meta property="article:tag" content="Design Patterns">
    <meta property="article:tag" content="Cours">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Design Patterns">
  <meta name="twitter:description" content="C’est quoi ? Les patterns offrent des solutions à des problèmes récurrents rencontrés par les développeurs, Ils permettent de :
Limiter le couplage Faciliter la maintenance Être moins rigide face au changement Ils sont indispensables à connaître pour le développeur :
Pour s’assurer d’une meilleure conception Pour dialoguer avec les développeurs (à travers le “langage pattern”) Pour comprendre les frameworks Un livre écrit par le GoF (Gang of Four : Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides) décrit 23 Design Patterns appliqués à la conception orientée objet, classés en trois catégories :">

        <link href="http://localhost:1313/blog/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/blog/css/main.f062b1e4d6ac1c4443e88d60ba62e8333196c89c434d7c5818faa94ec761a1b4.css" /><script type="text/javascript"
		src="http://localhost:1313/blog/js/MathJax.js"></script>
		
		<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']],
				displayMath: [['$$','$$'], ['\[','\]']],
				processEscapes: true,
				processEnvironments: true,
				skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
				TeX: { equationNumbers: { autoNumber: "AMS" },
						 extensions: ["AMSmath.js", "AMSsymbols.js"] }
			}
		});
		</script><link rel="stylesheet" href="http://localhost:1313/blog/katex/katex.min.css ">
		<script defer src="http://localhost:1313/blog/katex/katex.min.js"></script>
		<script defer src="http://localhost:1313/blog/katex/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
		
		<script>
			document.addEventListener("DOMContentLoaded", function() {
					renderMathInElement(document.body, {
							delimiters: [
									{left: "$$", right: "$$", display: true},
									{left: "$", right: "$", display: false}
							]
					});
			});
		</script>
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="http://localhost:1313/">Geoffrey</a>
	</div>
	<nav>
		
		<a href="/blog/">Home</a>
		
		<a href="/blog/posts">All posts</a>
		
		<a href="/blog/about">About</a>
		
		<a href="/blog/tags">Tags</a>
		
		
	</nav>
</header>

<main>
  <article>
    <div class="post-container">
      
      <div class="post-content">
        <div class="title">
          <h1 class="title">Design Patterns</h1>
          <div class="meta">Posted on Apr 24, 2023</div>
        </div>
        
        <section class="body">
          <h2 id="cest-quoi-">C’est quoi ?</h2>
<p>Les patterns offrent des solutions à des problèmes récurrents rencontrés par les développeurs, Ils permettent de :</p>
<ul>
<li>Limiter le couplage</li>
<li>Faciliter la maintenance</li>
<li>Être moins rigide face au changement</li>
</ul>
<p>Ils sont indispensables à connaître pour le développeur :</p>
<ul>
<li>Pour s’assurer d’une meilleure conception</li>
<li>Pour dialoguer avec les développeurs (à travers le “langage pattern”)</li>
<li>Pour comprendre les frameworks</li>
</ul>
<p>Un livre écrit par le <a href="https://fr.wikipedia.org/wiki/Patron_de_conception">GoF (Gang of Four : Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides)</a> décrit 23 Design Patterns appliqués à la conception orientée objet, classés en trois catégories :</p>
<h2 id="creational-patterns">Creational patterns</h2>
<p>Les patterns de <strong>création</strong>, relatifs à la création d’objet.</p>
<h3 id="singleton">Singleton</h3>
<p>Une seule instance d’une classe.</p>
<h3 id="prototype">Prototype</h3>
<ul>
<li>Clone,</li>
<li>Héritage de prototype</li>
</ul>
<h3 id="builder">Builder</h3>
<ul>
<li>Construire un objet avec plusieurs éléments choisi (recette de cuisine).</li>
<li>Permet de construire un objet complexe étape par étape.</li>
<li>Le constructeur est appelé à chaque étape de la construction de l&rsquo;objet.</li>
<li>Le client n&rsquo;a pas besoin de connaître les étapes de construction de l&rsquo;objet, il suffit de lui fournir un objet de construction. Le pattern Builder est utilisé pour construire des objets complexes étape par étape. Il permet de séparer la construction d&rsquo;un objet complexe de sa représentation finale, de sorte que le même processus de construction puisse créer différentes représentations.</li>
</ul>
<h3 id="factory">Factory</h3>
<p>Fabrique des objets en fonction d’un paramètre.</p>
<h3 id="abstract-factory">Abstract factory</h3>
<p>Fabrique des objets en fonction d’un paramètre, mais avec plusieurs usines, Par exemple pour implémenter une charte graphique : il existe une fabrique qui retourne des objets (boutons, menus) dans le style de Windows, une qui retourne des objets dans le style de Motif, et une dans le style de Macintosh. Une fabrique abstraite est obtenue en utilisant une fabrique simple.</p>
<h2 id="structural-patterns">Structural patterns</h2>
<p>Les patterns <strong>structuraux</strong>, qui structurent l’organisation des classes entre elles, comment elles sont liées.</p>
<h3 id="adapter">Adapter</h3>
<p>Adapte une interface à une autre:</p>
<ul>
<li>On veut utiliser une classe existante, mais dont l’interface ne coïncide pas avec celle escompté.</li>
<li>On souhaite créer une classe réutilisable qui collabore avec des classes sans relations avec elle et encore inconnues, c’est-à-dire avec des classes qui n’auront pas nécessairement des interfaces compatibles.</li>
<li>On a besoin d’utiliser plusieurs sous-classes existantes, mais l’adaptation de leur interface par dérivation de chacune d’entre elles est impraticable. Un adaptateur peut adapter l’interface de sa classe parente.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>@startuml
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>abstract Cible{
</span></span><span style="display:flex;"><span> + requete()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Adaptateur : + requete()
</span></span><span style="display:flex;"><span>Adapté : + requeteSpécifique()
</span></span><span style="display:flex;"><span>note &#34;requeteSpécifique()&#34; as N1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Client -&gt; Cible
</span></span><span style="display:flex;"><span>Cible &lt;|-- Adaptateur
</span></span><span style="display:flex;"><span>Adapté &lt;-- Adaptateur
</span></span><span style="display:flex;"><span>Adaptateur . N1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>@enduml
</span></span></code></pre></div><h3 id="composite">Composite</h3>
<p>Permet d’agencer les objets dans des arborescences afin de pouvoir traiter de la même et unique façon les objets individuels et les combinaisons de ceux-ci. <em>un objet contient d’autres objets</em> :</p>
<ul>
<li>Un système de fichier</li>
<li>Des objets graphiques (conteneurs et éléments graphiques élémentaire)</li>
<li>DOM</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>@startuml
</span></span><span style="display:flex;"><span>skinparam groupInheritance 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>class Client {
</span></span><span style="display:flex;"><span>    + main()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>abstract Composant {
</span></span><span style="display:flex;"><span>    + opération()
</span></span><span style="display:flex;"><span>    + ajouter(c: Composant)
</span></span><span style="display:flex;"><span>    + supprimer(c: Composant)
</span></span><span style="display:flex;"><span>    + getEnfant(i: int)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>class Feuille{
</span></span><span style="display:flex;"><span>    + opération()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>class Composite{
</span></span><span style="display:flex;"><span>    + opération()
</span></span><span style="display:flex;"><span>    + ajoute(c: Composant)
</span></span><span style="display:flex;"><span>    + supprimer(c Composant)
</span></span><span style="display:flex;"><span>    + getEnfant(i; Int)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>note &#34;pour tout g parmi enfant g.opération();&#34; as N
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Client -&gt; Composant
</span></span><span style="display:flex;"><span>Composant &lt;|-- Feuille
</span></span><span style="display:flex;"><span>Composant &lt;|-- Composite
</span></span><span style="display:flex;"><span>Composant &#34;1..*&#34;&lt;-- Composite
</span></span><span style="display:flex;"><span>Composite .. N
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>@enduml
</span></span></code></pre></div><h3 id="decorator">Decorator</h3>
<p>Un objet contient un autre objet, et ajoute des fonctionnalités <em>surchargeant les méthodes.</em>
Permet d&rsquo;ajouter des fonctionnalités à un objet de manière dynamique.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>@startuml
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>abstract Composant{
</span></span><span style="display:flex;"><span> + opération()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ComposantConcret : + opération()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>abstract Décorateur{
</span></span><span style="display:flex;"><span> + opération()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>class DécorateurConcretA{
</span></span><span style="display:flex;"><span> - étatAjouté : int
</span></span><span style="display:flex;"><span> + oprétion()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>class DécorateurConcretB{
</span></span><span style="display:flex;"><span> + opération()
</span></span><span style="display:flex;"><span> + comportementAjouté()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>note right of Décorateur : composant.opération()
</span></span><span style="display:flex;"><span>note right of DécorateurConcretB : Décoration.opération();\ncomportementAjouté();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Composant &lt;|- ComposantConcret
</span></span><span style="display:flex;"><span>Composant &lt;|-- Décorateur
</span></span><span style="display:flex;"><span>Composant &lt;-- Décorateur
</span></span><span style="display:flex;"><span>Décorateur &lt;|-- DécorateurConcretA
</span></span><span style="display:flex;"><span>Décorateur &lt;|-- DécorateurConcretB
</span></span><span style="display:flex;"><span>@enduml
</span></span></code></pre></div><h3 id="facade">Facade</h3>
<p>Permet de fournir une interface unifiée pour un ensemble d&rsquo;interfaces dans un sous-système.</p>
<h2 id="behavioral-patterns">Behavioral patterns</h2>
<p>Les patterns <strong>comportementaux</strong>, qui définissent la communication entre objets.</p>
<h3 id="strategy">Strategy</h3>
<p>Permet de définir une famille d&rsquo;algorithmes, encapsuler chacun d&rsquo;eux et les rendre interchangeables. En général, les clients créent un objet StrategieConcrete, et le passent au contexte, par la suite les clients interagissent exclusivement avec le contexte.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>@startuml
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>class contexte{
</span></span><span style="display:flex;"><span> + interfaceContexte()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Abstract Stratégie{
</span></span><span style="display:flex;"><span> + interfaceAlgorithme()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>StratégieConcrèteA : + interfaceAlgorithme()
</span></span><span style="display:flex;"><span>StratégieConcrèteB : + interfaceAlgorithme()
</span></span><span style="display:flex;"><span>StratégieConcrèteC : + interfaceAlgorithme()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>contexte -&gt; Stratégie
</span></span><span style="display:flex;"><span> Stratégie &lt;|-- StratégieConcrèteA
</span></span><span style="display:flex;"><span> Stratégie &lt;|-- StratégieConcrèteB
</span></span><span style="display:flex;"><span> Stratégie &lt;|-- StratégieConcrèteC
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>@enduml
</span></span></code></pre></div><h3 id="command">Command</h3>
<p>Un objet encapsule une commande, et peut l’exécuter, encapsuler une demande sous la forme d&rsquo;un objet, ce qui permet de paramétrer les clients avec différentes demandes.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>@startuml
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>abstract Commande {
</span></span><span style="display:flex;"><span>    + execute()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>class CommandeConcrete{
</span></span><span style="display:flex;"><span>    + execute()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>class Recepteur {
</span></span><span style="display:flex;"><span>    + action()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>note &#34;Recepteur.action()&#34; as N1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Invocateur -&gt; Commande
</span></span><span style="display:flex;"><span>Commande &lt;|-- CommandeConcrete
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Client .&gt; CommandeConcrete 
</span></span><span style="display:flex;"><span>Client -&gt; Recepteur
</span></span><span style="display:flex;"><span>CommandeConcrete --&gt; Recepteur
</span></span><span style="display:flex;"><span>CommandeConcrete .. N1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>@enduml
</span></span></code></pre></div><h3 id="iterator">Iterator</h3>
<p>Permets de parcourir les éléments d’une collection sans révéler sa représentation interne (liste, pile, arbre, etc.).
Même appel pour n&rsquo;importe quel type de collection, en java on utilise l&rsquo;interface Iterable et l&rsquo;interface Iterator
<code>java.util.Iterator</code> et <code>java.lang.Iterable</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>@startuml
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>class Client {
</span></span><span style="display:flex;"><span>    + main()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>interface Iterateur{
</span></span><span style="display:flex;"><span> + suivant()
</span></span><span style="display:flex;"><span> + existeSuivant()
</span></span><span style="display:flex;"><span> + supprimer()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>abstract Agregat{
</span></span><span style="display:flex;"><span> {abstract} + créeItérateur()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>class AgregatContret{
</span></span><span style="display:flex;"><span> + créeItérateur()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Agregat &lt;-Client
</span></span><span style="display:flex;"><span>Client -&gt; Iterateur
</span></span><span style="display:flex;"><span>Agregat &lt;|-- AgregatContret
</span></span><span style="display:flex;"><span>Iterateur &lt;|-- ItérateurConcret
</span></span><span style="display:flex;"><span>AgregatContret -&gt; ItérateurConcret
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>note &#34;return new ItérateurConcret(this)&#34; as N1
</span></span><span style="display:flex;"><span>AgregatContret .. N1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>@enduml
</span></span></code></pre></div><h3 id="observer">Observer</h3>
<p>Permet à un objet de surveiller l&rsquo;état d&rsquo;un autre objet et d&rsquo;être informé lorsque cet état change, Le design pattern Observer est utilisé pour établir une relation de type &ldquo;un-à-plusieurs&rdquo; entre des objets, où un objet principal, appelé &ldquo;sujet&rdquo; (ou &ldquo;observable&rdquo;), informe plusieurs autres objets, appelés &ldquo;observateurs&rdquo;, lorsqu&rsquo;il subit un changement d&rsquo;état. L&rsquo;idée est de définir une relation de dépendance entre ces objets sans les coupler de manière rigide. Cela permet de mettre à jour automatiquement les observateurs lorsque le sujet change d&rsquo;état, sans avoir à les relier explicitement.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>@startuml
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>abstract Sujet{
</span></span><span style="display:flex;"><span> + attache(o : Observateur)
</span></span><span style="display:flex;"><span> + détache(o : Observateur)
</span></span><span style="display:flex;"><span> + notifie()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>abstract Observateur{
</span></span><span style="display:flex;"><span> + miseAJour()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ObservateurConcret : + miseAJour()
</span></span><span style="display:flex;"><span>note &#34;Pour tout o dans Observateurs\n o.miseAJour()&#34; as N
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Sujet -&gt; Observateur
</span></span><span style="display:flex;"><span>Sujet &lt;|-- SujetConcret 
</span></span><span style="display:flex;"><span>Observateur &lt;|-- ObservateurConcret 
</span></span><span style="display:flex;"><span>Sujet .. N
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>@enduml
</span></span></code></pre></div><h3 id="mediator">Mediator</h3>
<p>Un objet centralise la communication entre plusieurs, objets, associe un objet à un autre (centrale d&rsquo;avion).</p>
<h3 id="state">State</h3>
<p>Un objet change de comportement en fonction de son état (ex: un bouton qui change de couleur en fonction de son état).
Modélise des objets dont le comportement varie en fonction de leur état interne. L&rsquo;idée est de définir une classe abstraite représentant l&rsquo;état général d&rsquo;un objet, et des sous-classes concrètes représentant les différents états spécifiques. Chaque état peut définir ses propres comportements pour les différentes méthodes de l&rsquo;objet. L&rsquo;objet principal, appelé &ldquo;contexte&rdquo;, maintient une référence à un objet d&rsquo;état particulier, qui détermine le comportement actuel de l&rsquo;objet. En modifiant l&rsquo;état du contexte, on peut modifier le comportement de l&rsquo;objet.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>@startuml
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Contexte : + requette()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>abstract État{
</span></span><span style="display:flex;"><span> + gerer(): void
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ÉtatAConcret : + gerer()
</span></span><span style="display:flex;"><span>ÉtatBConcret : + gerer()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>note bottom of Contexte : etat.gerer()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Contexte -&gt; État
</span></span><span style="display:flex;"><span>État &lt;|-- ÉtatAConcret
</span></span><span style="display:flex;"><span>État &lt;|-- ÉtatBConcret
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>@enduml
</span></span></code></pre></div><h3 id="visitor">Visitor</h3>
<p>Utilisez le pattern Visiteur quand vous voulez ajouter des capacités à un ensemble composite d’objets et que l’encapsulation n’est pas importante.
Le Visiteur doit parcourir chaque élément du Composite : cette fonctionnalité se trouve dans un objet Navigateur. Le Visiteur est guidé par le Navigateur et recueille l’état de tous les objets du Composite. Une fois l’état recueilli, le Client peut demander au Visiteur d’exécuter différentes opérations sur celui-ci. Quand une nouvelle fonctionnalité est requise, seul le Visiteur doit être modifié.</p>
<ul>
<li>Permet d’ajouter des opérations à la structure d’un Composite sans modifier la structure elle-même.</li>
<li>L’encapsulation des classes du Composite est brisée.</li>
<li>Comme une fonction de navigation est impliquée, les modifications de la structure du Composite sont plus difficiles.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>@startuml
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>abstract Visiteur{
</span></span><span style="display:flex;"><span> + visiteurElementconcretA(elemConcretA)
</span></span><span style="display:flex;"><span> + visiteurElementconcretB(elemConcretB)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>class VisiteurConcrèt1{
</span></span><span style="display:flex;"><span> + visiteurElementconcretA(elemConcretA)
</span></span><span style="display:flex;"><span> + visiteurElementconcretB(elemConcretB)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>class VisiteurConcrèt2{
</span></span><span style="display:flex;"><span> + visiteurElementconcretA(elemConcretA)
</span></span><span style="display:flex;"><span> + visiteurElementconcretB(elemConcretB)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>abstract Élement{
</span></span><span style="display:flex;"><span> + accept(v: Visiteur)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>class ÉlementConcrètA{
</span></span><span style="display:flex;"><span> + accept(v: Visiteur)
</span></span><span style="display:flex;"><span> + opérationA()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>class ÉlementConcrètB{
</span></span><span style="display:flex;"><span> + accept(v: Visiteur)
</span></span><span style="display:flex;"><span> + opérationB()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>note &#34;v.visiteElelementConcretA()&#34; as N
</span></span><span style="display:flex;"><span>note &#34;v.visiteElelementConcretB()&#34; as N2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Client -&gt; Visiteur
</span></span><span style="display:flex;"><span>Visiteur &lt;|-- VisiteurConcrèt1
</span></span><span style="display:flex;"><span>Visiteur &lt;|-- VisiteurConcrèt2
</span></span><span style="display:flex;"><span>Client ---&gt; StuctureDObjet
</span></span><span style="display:flex;"><span>StuctureDObjet -&gt; Élement
</span></span><span style="display:flex;"><span>Élement &lt;|-- ÉlementConcrètA
</span></span><span style="display:flex;"><span>Élement &lt;|-- ÉlementConcrètB
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ÉlementConcrètA . N
</span></span><span style="display:flex;"><span>ÉlementConcrètB . N2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>@enduml
</span></span></code></pre></div><h2 id="les-inconvénients-des-patterns">Les inconvénients des patterns</h2>
<ul>
<li>Ils occasionnent plus de classes</li>
<li>Ils peuvent être peu adaptés dans des environnements dit “limités” (comme Android)</li>
<li>c’est à encapsuler ce qui varie.</li>
<li>Ce principe nous enseigne à limiter chaque classe à une seule responsabilité. (Cohésion)</li>
<li>Nous savons que nous devons éviter comme la peste de changer quelque chose à une classe (Couplage)</li>
</ul>
<h2 id="autres-patrons-de-conception">Autres patrons de conception</h2>
<h3 id="object-pool">Object Pool</h3>
<p>Ce patron permet d&rsquo;économiser les temps d&rsquo;instanciation et de suppression lorsque de nombreux objets ont une courte durée d&rsquo;utilisation. Il consiste à administrer une collection d&rsquo;objets qui peuvent être recyclés. Une méthode du Pool délivre un objet soit par une nouvelle instanciation, soit par recyclage d&rsquo;un objet périmé. Lorsque les objets arrivent à la fin de leur cycle de vie, ils sont remis à la disposition du Pool pour un futur recyclage. Dans la phase d&rsquo;instanciation, le Pool peut instancier plus d&rsquo;un objet à la fois si l&rsquo;algorithme d&rsquo;instanciation a une complexité meilleure que O(n). Le patron Object Pool est particulièrement utile lorsque le nombre total de cycles de vie est très grand devant le nombre d&rsquo;instances à un moment précis et que les opérations d&rsquo;instanciation et/ou suppression sont coûteuses en temps d&rsquo;exécution par rapport à leur recyclage.</p>
<h3 id="modèle-vue-contrôleur">Modèle-vue-contrôleur</h3>
<p>Combinaison des patrons observateur, stratégie et composite, ce qui forme ainsi un patron d&rsquo;architecture.</p>
<h3 id="inversion-de-contrôle">Inversion de contrôle</h3>
<h3 id="injection-de-dépendances">Injection de dépendances</h3>
<h2 id="les-principes-de-conception-orientée-objet">Les principes de conception Orientée Objet</h2>
<h3 id="principe-ouvert-fermé">Principe Ouvert-Fermé</h3>
<blockquote>
<p>Les classes doivent être ouvertes à l’extension mais fermées au changement.</p></blockquote>
<ul>
<li>Ouvert à l’ajout de code</li>
<li>Fermé aux modifications du code existant</li>
<li>Ne pas modifier le code qui fonctionne, ce qui est stable doit rester stable.</li>
</ul>
<h3 id="principe-dinversion-des-dépendances">Principe d’inversion des dépendances</h3>
<blockquote>
<p>Dépendez des abstractions et non des classes concrètes.</p></blockquote>
<ul>
<li>Les modules de haut niveau ne doivent pas dépendre des classes concrètes d’un module de bas niveau</li>
<li>Les deux doivent dépendre d’abstraction</li>
</ul>
<h3 id="principe-dhollywood">Principe d’Hollywood</h3>
<blockquote>
<p>“Ne nous appelez pas, nous vous appelerons.”</p></blockquote>
<p>Les composants de bas niveau doivent s’adapter à un système, mais ce sont les composants de haut niveau qui déterminent quand appeler les composants de bas niveau.</p>
<p>Hollywood correspond aux composants de haut niveau, les acteurs correspondent aux composants de bas niveau. C’est Hollywood qui appelle les acteurs.</p>
<h3 id="autres-principes-en-vrac">Autres principes en vrac</h3>
<ul>
<li>Programmez des interfaces</li>
<li>Encapsulez ce qui varie</li>
<li>Couplez faiblement vos objets</li>
<li>Préférez la composition à l’héritage (“à un” plutôt que “est un”)</li>
<li>Une classe = Une responsabilité</li>
<li>Qui est responsable de ?</li>
</ul>
<hr>
<h2 id="source">source</h2>
<ul>
<li>wikipedia</li>
<li>headfirst : design patterns</li>
<li>mes cours</li>
<li>Fiche de revision de Théo</li>
</ul>

        </section>
        <div class="post-tags">
          
          
          <nav class="nav tags">
            <ul class="tags">
              
              <li><a href="/tags/design-patterns">Design Patterns</a></li>
              
              <li><a href="/tags/cours">cours</a></li>
              
            </ul>
          </nav>
          
          
        </div>
      </div>

      
      
    </div>

    </article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/Attadeurtia" rel="me" title="GitHub"><svg class="feather">
   <use href="/blog/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#github" />
</svg></a><a class="border"></a><a class="soc" href="https://social.vivaldi.net/@Attadeurtia" rel="me" title="Mastodon"><svg class="feather">
   <use href="/blog/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#Mastodon" />
</svg></a><a class="border"></a></div>
  <div class="footer-info">
    2025  © Geoffrey |  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>

</div>
    </body>
</html>
